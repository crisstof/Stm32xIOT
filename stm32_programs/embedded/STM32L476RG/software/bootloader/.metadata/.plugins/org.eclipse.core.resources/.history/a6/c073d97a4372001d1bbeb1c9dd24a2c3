/*
******************************************************************************
File:     main.c
Info:     Generated by Atollic TrueSTUDIO(R) 9.3.0   2022-11-18

The MIT License (MIT)
Copyright (c) 2019 STMicroelectronics

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

******************************************************************************
*/

/* Includes */
#include "main.h"
#include "usart.h"

/*AJOUT code*/
#include "stm32l4xx_hal.h" //Delay
#include "stm32l4xx_hal_gpio.h"
#include "stm32l4xx_hal_gpio_ex.h"
#include "stm32l4xx_hal_uart.h"
#include "stdio.h"
#include <string.h>
/* Variable statique */
//static GPIO_InitTypeDef init ;//variable de ce type pour l’initialisation
/*FIN ajout de code*/
/* Private macro */
#define MAJOR 0 //Major Version Number
#define MINOR 1 //Minor Version Number


/* Private variables */
UART_HandleTypeDef huart1;
//UART_HandleTypeDef huart2;
//UART_InitTypeDef huart1;
 /* USER CODE BEGIN PV */
 const uint8_t BL_Version[2] = {MAJOR, MINOR};
/* Private function prototypes */
/* Private functions */
 void SystemClock_Config(void);

 static void goto_application(void);


/**
**===========================================================================
**
**  Abstract: main program
**
**===========================================================================
*/
int main(void)
{
  //int i = 0;

  /**
  *  IMPORTANT NOTE!
  *  The symbol VECT_TAB_SRAM needs to be defined when building the project
  *  if code has been located to RAM and interrupts are used. 
  *  Otherwise the interrupt table located in flash will be used.
  *  See also the <system_*.c> file and how the SystemInit() function updates 
  *  SCB->VTOR register.  
  *  E.g.  SCB->VTOR = 0x20000000;  
  */

  /* TODO - Add your application code here */
  /* TODO - Add your application code here */
     HAL_Init() ; //Initialisation comme ma prise en compte des fonctions comme le Delay.
     SystemClock_Config();
     MX_USART1_UART_Init();

     // SystemClock_config();
    // __HAL_RCC_GPIOA_CLK_ENABLE(); //valide la clock GPIOA

     /*Initialise le port */
    // init.Mode = GPIO_MODE_OUTPUT_PP  ;
     //init.Pull = GPIO_PULLUP;
     //init.Speed = GPIO_SPEED_FREQ_HIGH ;//HIGH, MEDIUM
     //init.Pin = GPIO_PIN_5 ;
     //INITIALISATION
     //HAL_GPIO_Init(GPIOA, &init) ;
     //huart1.Init();

      //ajout
         printf("Starting Bootloader (%d.%d)\n ", BL_Version[0],BL_Version[1]);
         HAL_GPIO_WritePin( GPIOA, GPIO_PIN_5, GPIO_PIN_SET); //Green LED ON
         HAL_Delay(3000); //9 Seconds Delay

         //char cartInit[30] = "carte INIT";
         //HAL_UART_Transmit(&huart1, (uint8_t *)cartInit, strlen(cartInit), HAL_MAX_DELAY);

         goto_application();

  /* Infinite loop */
  while (1)
  {
	//i++;
	//HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
	//HAL_Delay(5000);
  }
}


/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
  RCC_OscInitStruct.MSICalibrationValue = 0;
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_5;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }
  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
  {
    Error_Handler();
  }
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1|RCC_PERIPHCLK_USART2;
  PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
  PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
  {
    Error_Handler();
  }
}

/* USER CODE BEGIN 4 */
/**
 * @brief Print the characters to UART (printf)
 * @retval int
 */



/* USER CODE END 4 */


#ifdef __GNUC__
/*with GCC small printf (option LD Linket->Library->Small printf set to 'Yes')
 * calls __io_putchar */
int __io_putchar(int ch)
#else
int fputc(int ch, FILE *f)
#endif /*__GNUC__*/
{
	/*Pace your implementation of fputc here*/
	/* e.g. write a character to the UART3 and loop until the end of transmission*/
	//HAL_UART_Transmit(&huart1, (unint8_t *)&ch, 1, HAL_MAX_DELAY);
	HAL_UART_Transmit(&huart1,(uint8_t *)&ch, 1, HAL_MAX_DELAY);

	//HAL_UART_Transmit(&huart1, (uint8_t *)rxBuffer, strlen(rxBuffer), 500);

	return ch;
}



static void goto_application(void)
{
  printf("Gonna Jump to Application\n");
  HAL_Delay(2000);
  printf("calling application\n");
  HAL_Delay(2000);
 // void (*app_reset_handler) (void) = (void*) (*(volatile uint32_t *) (0x08000000 + 4));
    void (*app_reset_handler) (void) = (void(*)(void)) (*(volatile uint32_t *) (0x08020000 + 4));

    /*typedef  void (*pFunction)(void);
     * pFunction JumpToApplication;
     * uint32_t JumpAddress;
     *  // Start application software
  if(((*(__IO uint32_t*)APPLICATION_ADDRESS) & 0x2FFE0000 ) == 0x20000000)
  {
    // Set application address
    JumpAddress       = *(__IO uint32_t*) (APPLICATION_ADDRESS + 4);
    JumpToApplication = (pFunction) JumpAddress;

    // Init application stack pointer
    __set_MSP(*(__IO uint32_t*) APPLICATION_ADDRESS);

    // Start application
    JumpToApplication();
  }
     */

    //so they have to write stack address manually using the __set_MSP function
  //other startp_stm32l073rztx.s l62 reset handle sp (stack pointer)

  __set_MSP( ( *(volatile uint32_t *) 0x08000000) );

  HAL_GPIO_WritePin( GPIOA, GPIO_PIN_5, GPIO_PIN_RESET); //Green LED OFF


  //Let's call the application's reset handler using this function pointer
  app_reset_handler();//call the app reset handler
}


void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}
